(cpp/raw "namespace jank::cpp::operator_::equalequal::pass_binary_overload
          {
            struct foo
            {
              bool operator ==(long *l)
              {
                return a == *l;
              }

              /* Not used. Ensures we're offsetting fields correctly. */
              int padding{};
              int a{};
            };

            bool operator==(foo const &lhs, foo const &rhs)
            { return lhs.a == rhs.a; }
            bool operator==(int lhs, foo const &rhs)
            { return lhs == rhs.a; }
            bool operator==(foo const &lhs, int rhs)
            { return lhs.a == rhs; }
          }")
(let* [i0 (cpp/int.)
       i2 (cpp/int. 2)
       i10 (cpp/int. 10)
       lhs-foo (cpp/jank.cpp.operator_.equalequal.pass_binary_overload.foo. i0 i10)
       rhs-foo (cpp/jank.cpp.operator_.equalequal.pass_binary_overload.foo. i0 i2)

       ; foo == foo
       _ (assert (= true (cpp/== lhs-foo lhs-foo)))
       _ (assert (= false (cpp/== lhs-foo rhs-foo)))

       ; int == foo
       _ (assert (= true (cpp/== i10 lhs-foo)))

       ; foo == int
       _ (assert (= true (cpp/== rhs-foo i2)))

       ; member foo == long
       l10 (cpp/long. 10)
       &l10 (cpp/& l10)
       _ (assert (= true (cpp/== lhs-foo &l10)))]
  :success)
