(cpp/raw "namespace jank::cpp::operator_::amp::pass_binary_overload
          {
            struct foo
            {
              foo& operator &(long *l)
              {
                a &= *l;
                return *this;
              }

              /* Not used. Ensures we're offsetting fields correctly. */
              int padding{};
              int a{};
            };

            foo operator&(foo const &lhs, foo const &rhs)
            { return { 0, lhs.a & rhs.a }; }
            foo operator&(int lhs, foo const &rhs)
            { return { 0, lhs & rhs.a }; }
            foo operator&(foo const &lhs, int rhs)
            { return { 0, lhs.a & rhs }; }
          }")
(let* [i0 (cpp/int.)
       i5 (cpp/int. 5)
       i10 (cpp/int. 10)
       lhs-foo (cpp/jank.cpp.operator_.amp.pass_binary_overload.foo. i0 i5)
       rhs-foo (cpp/jank.cpp.operator_.amp.pass_binary_overload.foo. i0 i10)

       ; foo & foo
       foos (cpp/& lhs-foo rhs-foo)
       _ (assert (= 0 (cpp/.-a foos)))

       ; int & foo
       i&foo (cpp/& i10 rhs-foo)
       _ (assert (= 10 (cpp/.-a i&foo)))

       ; foo & int
       foo&i (cpp/& lhs-foo i10)
       _ (assert (= 0 (cpp/.-a foo&i)))

       ; member foo & long
       l20 (cpp/long. 20)
       foo-member&l (cpp/& lhs-foo (cpp/& l20))
       _ (assert (= 4 (cpp/.-a foo-member&l)))]
  :success)
