(cpp/raw "namespace jank::cpp::operator_::lessless::pass_binary_overload
          {
            struct foo
            {
              foo& operator <<(long *l)
              {
                a <<= *l;
                return *this;
              }

              /* Not used. Ensures we're offsetting fields correctly. */
              int padding{};
              int a{};
            };

            foo operator<<(foo const &lhs, foo const &rhs)
            { return { 0, lhs.a << rhs.a }; }
            foo operator<<(int lhs, foo const &rhs)
            { return { 0, lhs << rhs.a }; }
            foo operator<<(foo const &lhs, int rhs)
            { return { 0, lhs.a << rhs }; }
          }")
(let* [i0 (cpp/int.)
       one (cpp/int. 1)
       i10 (cpp/int. 10)
       i25 (cpp/int. 25)
       lhs-foo (cpp/jank.cpp.operator_.lessless.pass_binary_overload.foo. i0 i10)
       rhs-foo (cpp/jank.cpp.operator_.lessless.pass_binary_overload.foo. i0 one)

       ; foo << foo
       foos (cpp/<< lhs-foo rhs-foo)
       _ (assert (= 20 (cpp/.-a foos)))

       ; int << foo
       i<<foo (cpp/<< i25 lhs-foo)
       _ (assert (= 25600 (cpp/.-a i<<foo)))

       ; foo << int
       foo<<i (cpp/<< lhs-foo one)
       _ (assert (= 20 (cpp/.-a foo<<i)))

       ; member foo << long
       l3 (cpp/long. 3)
       &l3 (cpp/& l3)
       foo-member<<l (cpp/<< lhs-foo &l3)
       _ (assert (= 80 (cpp/.-a foo-member<<l)))]
  :success)
