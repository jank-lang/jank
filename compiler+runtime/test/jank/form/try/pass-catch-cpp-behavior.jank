;; Tests for complex C++ exception behavior (rethrow, uncaught)

(cpp/raw "namespace pass_catch_cpp_behavior
          {
            void throw_runtime_error() { throw std::runtime_error(\"error\"); }
            void throw_current() { throw; }
          }")

;; 1. Rethrowing C++ exception
(let [a   (atom [])
      msg (atom nil)]
  (try
    (try
      (cpp/pass_catch_cpp_behavior.throw_runtime_error)
      (catch cpp/std.runtime_error e
        (swap! a conj :caught-inner)
        (cpp/pass_catch_cpp_behavior.throw_current)))
    ;; Rethrow using helper function
    (catch cpp/std.runtime_error e
      (swap! a conj :caught-outer)
      (reset! msg (cpp/.what e))))

  (assert (= [:caught-inner :caught-outer] @a) (pr-str @a))
  (assert (= "error" @msg) "Should preserve exception message on rethrow"))

;; 2. Uncaught C++ exception with finally
(let [a   (atom [])
      msg (atom nil)]
  (try
    (try
      (cpp/pass_catch_cpp_behavior.throw_runtime_error)
      ;; No matching catch for runtime_error (inner catch is for logic_error)
      (catch cpp/std.logic_error e
        (swap! a conj :wrong-catch))
      (finally
        (swap! a conj :finally-ran)))
    (catch cpp/std.runtime_error e
      (swap! a conj :caught-outer)
      (reset! msg (cpp/.what e))))

  (assert (= [:finally-ran :caught-outer] @a) (pr-str @a))
  (assert (= "error" @msg) "Should catch exception with correct message"))

:success
