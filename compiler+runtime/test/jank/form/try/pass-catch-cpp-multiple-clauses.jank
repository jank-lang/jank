;; Test multiple catch with C++ exceptions and finally blocks
(cpp/raw "namespace pass_multiple_catch_cpp_with_finally
          {
            void throw_uncaught_type() { throw 'x'; }
          }")

(cpp/raw "namespace pass_multiple_catch_cpp_with_finally
          {
            void throw_cpp_double() { throw 5.5; }
          }")

(let [cleanup (atom false)]
  (assert
   (= 5.5
      (try
        (cpp/pass_multiple_catch_cpp_with_finally.throw_cpp_double)
        (catch cpp/int i -1)
        (catch cpp/double d d)
        (catch cpp/std.runtime_error e -1.0)
        (finally
          (reset! cleanup true)))))
  (assert (true? @cleanup) "Finally should execute"))

;; Test finally executes even when exception is not caught
(let [cleanup (atom false)
      caught  (atom false)]
  (try
    (try
      (cpp/pass_multiple_catch_cpp_with_finally.throw_uncaught_type)
      (catch cpp/int i
        (reset! caught true))
      (catch cpp/double d
        (reset! caught true))
      (finally
        (reset! cleanup true)))
    (catch cpp/char c
      c))
  (assert (true? @cleanup) "Finally should execute before unwinding")
  (assert (false? @caught) "No inner catch should match")
  (assert
   (= \x
      (try (cpp/pass_multiple_catch_cpp_with_finally.throw_uncaught_type)
        (catch cpp/char c c)))
   "Should catch char 'x'"))

:success
