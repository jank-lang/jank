; Test 1: (case [:key1 :key2])
; test case in value position
(let [xfn
      (let* [clojure_core-G__-1 [:key1 :key2]]
        (case* clojure_core-G__-1 0 1 :default
                   {0 (clojure.core/condp clojure.core/= clojure_core-G__-1 [:key1 :key2] :matched
                        :default),
                    1 (clojure.core/condp clojure.core/= clojure_core-G__-1 :key :not-matched
                        :default)}
          :compact :hash-equiv nil))]
  (assert (= xfn :matched)))

; test case in statement position
(let [xfn (fn []
            (let* [clojure_core-G__-2 [:key1 :key2]]
              (case* clojure_core-G__-2 0 1 :default
                         {0 (clojure.core/condp clojure.core/= clojure_core-G__-2 [:key1 :key2] :matched
                              :default),
                          1 (clojure.core/condp clojure.core/= clojure_core-G__-2 :key :not-matched
                              :default)}
                :compact :hash-equiv nil))
            0)]
  (assert (= (xfn) 0)))

; test case in return position
(assert
 (=
  (let* [clojure_core-G__-3 [:key1 :key2]]
    (case* clojure_core-G__-3 0 1 :default
               {0 (clojure.core/condp clojure.core/= clojure_core-G__-3 [:key1 :key2] :matched
                    :default),
                1 (clojure.core/condp clojure.core/= clojure_core-G__-3 :key :not-matched
                    :default)}
      :compact :hash-equiv nil))
  :matched))


; Test 2: (case {:a 1 :b 2})
; test case in value position
(let [xfn
      (let* [clojure_core-G__-4396 {:a 1, :b 2}]
        (case* clojure_core-G__-4396 3 1 :default
                   {0 (clojure.core/condp clojure.core/= clojure_core-G__-4396 {:a 1, :b 2} :map-match
                        :default),
                    1 (clojure.core/condp clojure.core/= clojure_core-G__-4396 {:a 3, :b 4} :not-matched
                        :default)}
          :compact :hash-equiv nil))]
  (assert (= xfn :map-match)))

; test case in statement position
(let [xfn (fn []
            (let* [clojure_core-G__-4396 {:a 1, :b 2}]
              (case* clojure_core-G__-4396 3 1 :default
                         {0 (clojure.core/condp clojure.core/= clojure_core-G__-4396 {:a 1, :b 2} :map-match
                              :default),
                          1 (clojure.core/condp clojure.core/= clojure_core-G__-4396 {:a 3, :b 4} :not-matched
                              :default)}
                :compact :hash-equiv nil))
            0)]
  (assert (= (xfn) 0)))

; test case in return position
(assert
 (=
  (let* [clojure_core-G__-4396 {:a 1, :b 2}]
    (case* clojure_core-G__-4396 3 1 :default
               {0 (clojure.core/condp clojure.core/= clojure_core-G__-4396 {:a 1, :b 2} :map-match
                    :default),
                1 (clojure.core/condp clojure.core/= clojure_core-G__-4396 {:a 3, :b 4} :not-matched
                    :default)}
      :compact :hash-equiv nil))
  :map-match))


; Test 3: (case [1 2 3])
; test case in value position
(let [xfn
      (let* [clojure_core-G__-4402 [1 2 3]]
        (case* clojure_core-G__-4402 2 3 :default
                   {0 (clojure.core/condp clojure.core/= clojure_core-G__-4402 1 :one
                        :default),
                    1 (clojure.core/condp clojure.core/= clojure_core-G__-4402 [1 2 3] :vector-match
                        :default),
                    2 (clojure.core/condp clojure.core/= clojure_core-G__-4402 [4 5 6] :not-matched
                        :default)}
          :compact :hash-equiv nil))]
  (assert (= xfn :vector-match)))

; test case in statement position
(let [xfn (fn []
            (let* [clojure_core-G__-4402 [1 2 3]]
              (case* clojure_core-G__-4402 2 3 :default
                         {0 (clojure.core/condp clojure.core/= clojure_core-G__-4402 1 :one
                              :default),
                          1 (clojure.core/condp clojure.core/= clojure_core-G__-4402 [1 2 3] :vector-match
                              :default),
                          2 (clojure.core/condp clojure.core/= clojure_core-G__-4402 [4 5 6] :not-matched
                              :default)}
                :compact :hash-equiv nil))
            0)]
  (assert (= (xfn) 0)))

; test case in return position
(assert
 (=
  (let* [clojure_core-G__-4402 [1 2 3]]
    (case* clojure_core-G__-4402 2 3 :default
               {0 (clojure.core/condp clojure.core/= clojure_core-G__-4402 1 :one
                    :default),
                1 (clojure.core/condp clojure.core/= clojure_core-G__-4402 [1 2 3] :vector-match
                    :default),
                2 (clojure.core/condp clojure.core/= clojure_core-G__-4402 [4 5 6] :not-matched
                    :default)}
      :compact :hash-equiv nil))
  :vector-match))


; Test 4: (case [[1 2]])
; test case in value position
(let [xfn
      (let* [clojure_core-G__-4396 [[1 2]]]
        (case* clojure_core-G__-4396 0 1 :default
                   {0 (clojure.core/condp clojure.core/= clojure_core-G__-4396 [{:a 1}] :map-list-match
                        :default),
                    1 (clojure.core/condp clojure.core/= clojure_core-G__-4396 [[1 2]] :vector-match
                        :default)}
          :compact :hash-equiv nil))]
  (assert (= xfn :vector-match)))

; test case in statement position
(let [xfn (fn []
            (let* [clojure_core-G__-4396 [[1 2]]]
              (case* clojure_core-G__-4396 0 1 :default
                         {0 (clojure.core/condp clojure.core/= clojure_core-G__-4396 [{:a 1}] :map-list-match
                              :default),
                          1 (clojure.core/condp clojure.core/= clojure_core-G__-4396 [[1 2]] :vector-match
                              :default)}
                :compact :hash-equiv nil))
            0)]
  (assert (= (xfn) 0)))

; test case in return position
(assert
 (=
  (let* [clojure_core-G__-4396 [[1 2]]]
    (case* clojure_core-G__-4396 0 1 :default
               {0 (clojure.core/condp clojure.core/= clojure_core-G__-4396 [{:a 1}] :map-list-match
                    :default),
                1 (clojure.core/condp clojure.core/= clojure_core-G__-4396 [[1 2]] :vector-match
                    :default)}
      :compact :hash-equiv nil))
  :vector-match))


; Test 5: (case {:a 1})
; test case in value position
(let [xfn
      (let* [clojure_core-G__-4396 {:a 1}]
        (case* clojure_core-G__-4396 9 1 :default
                   {0 (clojure.core/condp clojure.core/= clojure_core-G__-4396 {:b 2} :different-map
                        :default),
                    1 (clojure.core/condp clojure.core/= clojure_core-G__-4396 {:a 1} :map-match
                        :default)}
          :compact :hash-equiv nil))]
  (assert (= xfn :map-match)))

; test case in statement position
(let [xfn (fn []
            (let* [clojure_core-G__-4396 {:a 1}]
              (case* clojure_core-G__-4396 9 1 :default
                         {0 (clojure.core/condp clojure.core/= clojure_core-G__-4396 {:b 2} :different-map
                              :default),
                          1 (clojure.core/condp clojure.core/= clojure_core-G__-4396 {:a 1} :map-match
                              :default)}
                :compact :hash-equiv nil))
            0)]
  (assert (= (xfn) 0)))

; test case in return position
(assert
 (=
  (let* [clojure_core-G__-4396 {:a 1}]
    (case* clojure_core-G__-4396 9 1 :default
               {0 (clojure.core/condp clojure.core/= clojure_core-G__-4396 {:b 2} :different-map
                    :default),
                1 (clojure.core/condp clojure.core/= clojure_core-G__-4396 {:a 1} :map-match
                    :default)}
      :compact :hash-equiv nil))
  :map-match))

:success