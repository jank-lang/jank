;; value position tests
(let [x
      (case 1 1 :one
        2       :two
        "3"     :three
        :default)]
  (assert (= x :one) "Integer match - value position"))

(let [x (case "3" 1 :one
          2         :two
          "3"       :three
          :default)]
  (assert (= x :three) "String match - value position"))

(let [x (case true true :yes
          false         :no
          :default)]
  (assert (= x :yes) "Boolean match - value position"))

(let [x (case nil nil :empty
          false       :false-value
          :default)]
  (assert (= x :empty) "Nil match - value position"))

(let [x (case 0 0 :zero
          1       :one
          2       :two
          :default)]
  (assert (= x :zero) "Zero match - value position"))

(let [x
      (case "hello" "world" :world "hello"             :greeting "Clojure"           :language :default)
      ]
  (assert (= x :greeting) "String hello match - value position"))

(let [x
      (case 3.14 3.14 :pi 2.71          :e 1.61          :phi :default)
      ]
  (assert (= x :pi) "Float match - value position"))

(let [x (case 'symbol symbol :symbol-match
          other              :symbol-no-match
          :symbol-fallback)]
  (assert (= x :symbol-match) "Symbol match - value position"))

(let [x
      (case "AaAaAaAa" "AaAaAaAa" :hasha
        "BBBBBBBB"                :hashb
        :default)]
  (assert (= x :hasha) "Hash collision check - value position"))

;; tail position tests
(let [f (fn []
          (case 1 1 :one
            2       :two
            "3"     :three
            :default))]
  (assert (= (f) :one) "Integer match - tail position"))

(let [f (fn []
          (case "3" 1 :one
            2         :two
            "3"       :three
            :default))]
  (assert (= (f) :three) "String match - tail position"))

(let [f (fn []
          (case true true :yes
            false         :no
            :default))]
  (assert (= (f) :yes) "Boolean match - tail position"))

(let [f (fn []
          (case nil nil :empty
            false       :false-value
            :default))]
  (assert (= (f) :empty) "Nil match - tail position"))

(let [f (fn []
          (case 0 0 :zero
            1       :one
            2       :two
            :default))]
  (assert (= (f) :zero) "Zero match - tail position"))

(let [f (fn []
          (case "hello" "world" :world
            "hello"             :greeting
            "Clojure"           :language
            :default))]
  (assert (= (f) :greeting) "String hello match - tail position"))

(let [f (fn []
          (case 3.14 3.14 :pi
            2.71          :e
            1.61          :phi
            :default))]
  (assert (= (f) :pi) "Float match - tail position"))

(let [f (fn []
          (case 'symbol symbol :symbol-match
            other              :symbol-no-match
            :symbol-fallback))]
  (assert (= (f) :symbol-match) "Symbol match - tail position"))

(let [f (fn []
          (case "AaAaAaAa" "AaAaAaAa" :hasha
            "BBBBBBBB"                :hashb
            :default))]
  (assert (= (f) :hasha) "Hash collision check - tail position"))

;; statement position tests
(let [f (fn []
          (case 1 1 :one
            2       :two
            "3"     :three
            :default)
          :ignored)]
  (assert (= (f) :ignored) "Integer match - statement position"))

(let [f (fn []
          (case "3" 1 :one
            2         :two
            "3"       :three
            :default)
          :ignored)]
  (assert (= (f) :ignored) "String match - statement position"))

(let [f (fn []
          (case true true :yes
            false         :no
            :default)
          :ignored)]
  (assert (= (f) :ignored) "Boolean match - statement position"))

(let [f (fn []
          (case nil nil :empty
            false       :false-value
            :default)
          :ignored)]
  (assert (= (f) :ignored) "Nil match - statement position"))

(let [f (fn []
          (case 0 0 :zero
            1       :one
            2       :two
            :default)
          :ignored)]
  (assert (= (f) :ignored) "Zero match - statement position"))

(let [f (fn []
          (case "hello" "world" :world
            "hello"             :greeting
            "Clojure"           :language
            :default)
          :ignored)]
  (assert (= (f) :ignored) "String hello match - statement position"))

(let [f (fn []
          (case 3.14 3.14 :pi
            2.71          :e
            1.61          :phi
            :default)
          :ignored)]
  (assert (= (f) :ignored) "Float match - statement position"))

(let [f (fn []
          (case 'symbol symbol :symbol-match
            other              :symbol-no-match
            :symbol-fallback)
          :ignored)]
  (assert (= (f) :ignored) "Symbol match - statement position"))

(let [f (fn []
          (case "AaAaAaAa" "AaAaAaAa" :hasha
            "BBBBBBBB"                :hashb
            :default)
          :ignored)]
  (assert (= (f) :ignored) "Hash collision check - statement position"))

;; Character test (commented out as non-working)
#_(let [f (fn []
            (case \a \a \b
              \c        \d
              :not-found))]
    (assert (= (f) \b) "Character match"))

:success