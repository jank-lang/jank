; test case in statement position
(let [xfn (fn []
            (case 2 (0 1) :zero-or-one
              (2 3)       :two-or-three
              :default)
            :two-or-three)]
  (assert (= (xfn) :two-or-three)))

; test case in tail position
(let [xfn (fn []
            (case 2
              (0 1) :zero-or-one
              (2 3) :two-or-three
              :default))]
  (assert (= (xfn) :two-or-three)))

; test case in value position
(let [xfn
      (case 2
        (0 1) :zero-or-one
        (2 3) :two-or-three
        :default)]
  (assert (= xfn :two-or-three)))

; test case in value position
(let [xfn
      (case "b"
        ("a" "b" "c") :a-b-or-c
        ("x" "y" "z") :x-y-or-z
        :default)]
  (assert (= xfn :a-b-or-c)))

; test case in statement position
(let [xfn (fn []
            (case "b"
              ("a" "b" "c") :a-b-or-c
              ("x" "y" "z") :x-y-or-z
              :default)
            0)]
  (assert (= (xfn) 0)))

; test case in return position
(assert
 (=
  (case "b"
    ("a" "b" "c") :a-b-or-c
    ("x" "y" "z") :x-y-or-z
    :default)
  :a-b-or-c))

:success
