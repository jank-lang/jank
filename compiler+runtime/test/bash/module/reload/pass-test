#!/usr/bin/env bb

^{:clj-kondo/ignore [:namespace-name-mismatch]}
(ns jank.test.module.reload
  (:require [babashka.fs :as fs]
            [babashka.process :as ps]
            [clojure.string :as string]
            [clojure.java.io :as io]
            [clojure.test :as t :refer [deftest is testing]]))

(def this-nsym (ns-name *ns*))

(defn send-command [writer command]
  (doto writer
    (.write command)
    (.flush)))

(defn read-available [reader]
  (let [sb (StringBuilder.)]
    (while (.ready reader)
      (.append sb (char (.read reader))))
    (str sb)))

(defmacro with-backup [path & body]
  `(fs/with-temp-dir [dir#]
     (let [tmp-path# (fs/path dir# ~path)]
       (fs/copy-tree ~path tmp-path#)
       (try
         ~@body
         (finally
           (fs/delete-tree ~path)
           (fs/copy-tree tmp-path# ~path))))))

(deftest a-single-module-reload
  (with-backup "src/jank_test/reload"
    (let [proc (ps/process ["jank" "--module-path" "src" "repl"])
          dependent-module-path "src/jank_test/reload/dependent.cljc"
          dependency-module-path "src/jank_test/reload/dependency.cljc"
          original-dependent-content (slurp dependent-module-path)]
      (with-open [repl-writer (io/writer (:in proc))
                  repl-reader (io/reader (:out proc))]
        (doto repl-writer
          (send-command "(require '[jank-test.reload.dependent :as d])\n")
          (send-command "(d/first-fn)\n"))

        ;; Wait for repl to start
        (Thread/sleep 2000)
        (is (string/includes?
             (read-available repl-reader)
             "Hello"))

        (send-command repl-writer "(d/hi)\n")

        (Thread/sleep 500)
        (is (string/includes?
             (read-available repl-reader)
             "Unable to resolve symbol 'jank-test.reload.dependent/hi'"))

        (testing "new var should be added to the module"
          ;; Add a new var
          (doto dependent-module-path
            (spit "\n" :append true)
            (spit (pr-str '(defn hi [] "Hi!")) :append true))

          (doto repl-writer
            (send-command "(require '[jank-test.reload.dependent :as d] :reload)\n")
            (send-command "(d/hi)\n"))

          (Thread/sleep 500)
          (is (string/includes?
               (read-available repl-reader)
               "Hi!")))

        (testing "var removed from the source should still available"
          (spit dependent-module-path original-dependent-content)
          (doto repl-writer
            (send-command "(require '[jank-test.reload.dependent :as d] :reload)\n")
            (send-command "(d/hi)\n"))

          (Thread/sleep 500)
          (is (string/includes?
               (read-available repl-reader)
               "Hi!")))
        (testing "dependency module should not reload"
          (doto dependency-module-path
            (spit "\n" :append true)
            (spit (pr-str '(defn hi [] "Hi in dependency!")) :append true))
          (doto repl-writer
            (send-command "(require '[jank-test.reload.dependency :as dep])\n")
            (send-command "(require '[jank-test.reload.dependent :as d] :reload)\n")
            (send-command "(dep/hi)\n"))

          (Thread/sleep 500)

          (is (string/includes?
               (read-available repl-reader)
               "Unable to resolve symbol 'jank-test.reload.dependency/hi'"))))
      (ps/destroy proc))))

(deftest reload-all
  (with-backup "src/jank_test/reload_all"
    (let [proc (ps/process ["jank" "--module-path" "src" "repl"])
          dependent-module-path "src/jank_test/reload_all/dependent.cljc"
          dependency-module-path "src/jank_test/reload_all/dependency.cljc"]
      (with-open [repl-writer (io/writer (:in proc))
                  repl-reader (io/reader (:out proc))]
        (doto repl-writer
          (send-command "(require '[jank-test.reload-all.dependent :as d])\n")
          (send-command "(d/first-fn)\n"))

        ;; Wait for repl to start
        (Thread/sleep 2000)
        (is (string/includes?
             (read-available repl-reader)
             "Hello"))

        (send-command repl-writer "(d/hi)\n")

        (Thread/sleep 500)
        (is (string/includes?
             (read-available repl-reader)
             "Unable to resolve symbol 'jank-test.reload-all.dependent/hi'"))

        (testing "module is reloaded"
          ;; Add a new var
          (doto dependent-module-path
            (spit "\n" :append true)
            (spit (pr-str '(defn hi [] "Hi!")) :append true))

          (doto repl-writer
            (send-command "(require '[jank-test.reload-all.dependent :as d] :reload-all)\n")
            (send-command "(d/hi)\n"))

          (Thread/sleep 500)
          (is (string/includes?
               (read-available repl-reader)
               "Hi!")))

        (testing "module's dependency is also reloaded"
          (doto dependency-module-path
            (spit "\n" :append true)
            (spit (pr-str '(defn hi [] "Hi in dependency!")) :append true))

          (doto repl-writer
            (send-command "(require '[jank-test.reload-all.dependency :as dep])\n")
            (send-command "(dep/hi)\n"))

          (Thread/sleep 500)
          (is (string/includes?
               (read-available repl-reader)
               "Unable to resolve symbol 'jank-test.reload-all.dependency/hi'"))

          (doto repl-writer
            (send-command "(require '[jank-test.reload-all.dependent :as d] :reload-all)\n")
            (send-command "(dep/hi)\n"))

          (Thread/sleep 500)
          (is (string/includes?
               (read-available repl-reader)
               "Hi in dependency!"))))
      (ps/destroy proc))))

(defn -main []
  (System/exit
   (if (t/successful? (t/run-tests this-nsym))
     0
     1)))

(when (= *file* (System/getProperty "babashka.file"))
  (apply -main *command-line-args*))
