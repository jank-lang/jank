#include <fstream>
#include <vector>
#include <cstdlib>

#include <jtl/result.hpp>

#include <llvm/ADT/IntrusiveRefCntPtr.h>
#include <llvm/Option/OptTable.h>
#include <llvm/Support/Program.h>
#include <llvm/Support/TargetSelect.h>
#include <llvm/Support/VirtualFileSystem.h>
#include <llvm/Support/raw_ostream.h>
#include <llvm/TargetParser/Host.h>

#include <clang/Basic/DiagnosticIDs.h>
#include <clang/Basic/DiagnosticOptions.h>
#include <clang/Driver/Compilation.h>
#include <clang/Driver/Driver.h>
#include <clang/Driver/ToolChain.h>
#include <clang/Frontend/TextDiagnosticPrinter.h>

#include <jank/error/aot.hpp>
#include <jank/aot/processor.hpp>
#include <jank/util/cli.hpp>
#include <jank/util/fmt.hpp>
#include <jank/runtime/context.hpp>
#include <jank/runtime/module/loader.hpp>
#include <jank/util/fmt/print.hpp>
#include <jank/util/scope_exit.hpp>
#include <jank/util/string_builder.hpp>

namespace jank::aot
{
  using namespace jank::runtime;

  processor::processor(util::cli::options const &opts)
    : include_dirs{ opts.include_dirs }
    , library_dirs{ opts.library_dirs }
    , define_macros{ opts.define_macros }
    , libs{ opts.libs }
    , output_filename(opts.output_filename)
  {
  }

  static jtl::immutable_string relative_to_cache_dir(jtl::immutable_string const &file_path)
  {
    return util::format("{}/{}", __rt_ctx->binary_cache_dir, file_path);
  }

  // TODO: Generate an object file instead of a cpp
  static jtl::immutable_string gen_entrypoint(jtl::immutable_string const &module)
  {
    util::string_builder sb;
    sb(R"(/* DO NOT MODIFY: Autogenerated by jank. */

using jank_object_ref = void*;
using jank_bool = char;

    )");

    sb(R"(
extern "C" int jank_init(int const argc,
                     char const **argv,
                     jank_bool init_default_ctx,
                     int (*fn)(int const, char const **));
extern "C" jank_object_ref jank_var_intern(jank_object_ref ns, jank_object_ref var);
extern "C" jank_object_ref jank_call0(jank_object_ref f);
    )");

    sb(R"(
extern "C" jank_object_ref jank_load_clojure_core_native();
extern "C" jank_object_ref jank_load_clojure_string_native();
extern "C" jank_object_ref jank_load_jank_compiler_native();
extern "C" jank_object_ref jank_load_clojure_core();
extern "C" jank_object_ref jank_var_intern_c(char const *, char const *);
extern "C" jank_object_ref jank_deref(jank_object_ref);
extern "C" jank_object_ref jank_call2(jank_object_ref, jank_object_ref, jank_object_ref);
extern "C" jank_object_ref jank_parse_command_line_args(int, char const **);
)");

    auto const modules_rlocked{ __rt_ctx->loaded_modules_in_order.rlock() };
    for(auto const &it : *modules_rlocked)
    {
      util::format_to(sb,
                      R"(extern "C" jank_object_ref {}();)",
                      module::module_to_load_function(it));
      sb("\n");
    }

    sb(R"(

int main(int argc, const char** argv)
{
  auto const fn{ [](int const argc, char const **argv) {
    jank_load_clojure_core_native();
    jank_load_clojure_string_native();
    jank_load_jank_compiler_native();

    )");

    for(auto const &it : *modules_rlocked)
    {
      util::format_to(sb, "{}();\n", module::module_to_load_function(it));
    }

    sb(R"(auto const apply{ jank_var_intern_c("clojure.core", "apply") };)");
    sb("\n");
    sb(R"(auto const command_line_args{ jank_parse_command_line_args(argc, argv) };)");
    sb("\n");

    util::format_to(sb, R"(auto const fn(jank_var_intern_c("{}", "-main"));)", module);
    sb("\n");
    sb(R"(jank_call2(jank_deref(apply), jank_deref(fn), command_line_args);

    return 0;

  } };

  return jank_init(argc, argv, /* init_default_ctx= */ true, fn);
}
  )");

    auto const tmp_dir{ std::filesystem::temp_directory_path() };
    std::string main_file_path{ tmp_dir / "jank-main-XXXXXX" };

    auto const fd{ mkstemp(main_file_path.data()) };
    close(fd);

    std::ofstream out(main_file_path);
    out << sb.release();

    return main_file_path;
  }

  jtl::result<void, error_ref> processor::compile(jtl::immutable_string const &module) const
  {
    auto const entrypoint_path{ gen_entrypoint(module) };

    auto const diag_opts{ new clang::DiagnosticOptions() };
    auto *diag_client{
      new clang::TextDiagnosticPrinter{ llvm::errs(), &*diag_opts }
    };
    auto const diag_id{ new clang::DiagnosticIDs() };
    clang::DiagnosticsEngine diags{ diag_id, &*diag_opts, diag_client, /*ShouldOwnClient=*/true };

    auto const vfs{ llvm::vfs::getRealFileSystem() };

    auto const target_triple{ llvm::sys::getDefaultTargetTriple() };

    /* TODO: Ensure correct clang++ version. */
    auto clang_inferred_path{ llvm::sys::findProgramByName("clang++") };
    if(!clang_inferred_path)
    {
      return error::aot_clang_executable_not_found();
    }
    clang::driver::Driver driver{ clang_inferred_path.get(),
                                  target_triple,
                                  diags,
                                  "jank_aot_compilation",
                                  vfs };

    std::vector<char const *> compiler_args{ strdup(clang_inferred_path.get().c_str()) };

    auto const modules_rlocked{ __rt_ctx->loaded_modules_in_order.rlock() };
    for(auto const &it : *modules_rlocked)
    {
      auto const &module_path{ util::format("{}.o",
                                            relative_to_cache_dir(module::module_to_path(it))) };

      if(std::filesystem::exists(module_path.c_str()))
      {
        compiler_args.push_back(strdup(module_path.c_str()));
      }
      else
      {
        auto const find_res{ __rt_ctx->module_loader.find(module, module::origin::latest) };
        if(find_res.is_ok() && find_res.expect_ok().sources.o.is_some())
        {
          compiler_args.push_back(strdup(find_res.expect_ok().sources.o.unwrap().path.c_str()));
        }
        else
        {
          return error::internal_aot_failure(
            util::format("Compiled module '{}' not found.", module));
        }
      }
    }

    compiler_args.push_back(strdup("-x"));
    compiler_args.push_back(strdup("c++"));
    compiler_args.push_back(strdup(entrypoint_path.c_str()));

    for(auto const &include_dir : include_dirs)
    {
      compiler_args.push_back(strdup(util::format("-I{}", include_dir).c_str()));
    }

    // TODO: Find library paths for jank's dependencies and add them here instead of
    // expecting from users
    compiler_args.push_back(strdup(util::format("-L{}", JANK_DEPS_LIBRARY_DIRS).c_str()));
    for(auto const &library_dir : library_dirs)
    {
      compiler_args.push_back(strdup(util::format("-L{}", library_dir).c_str()));
    }

    for(auto const &lib : { "-ljank",
                            /* Default libraries that jank depends on. */
                            "-lfolly",
                            "-lgc",
                            "-lstdc++",
                            "-lgccpp",
                            "-lm",
                            "-lzippp_static",
                            "-lzip",
                            "-lbz2",
                            "-lcrypto",
                            "-lcpptrace",
                            "-ldwarf",
                            "-lz",
                            "-lzstd",
                            "-lclang-cpp",
                            "-lLLVM",
                            "-lnanobench",
                            "-lftxui-component",
                            "-lftxui-dom",
                            "-lftxui-screen" })
    {
      compiler_args.push_back(strdup(lib));
    }

    for(auto const &define : define_macros)
    {
      compiler_args.push_back(strdup(util::format("-D{}", define).c_str()));
    }

    compiler_args.push_back(strdup("-std=c++20"));

    compiler_args.push_back(strdup("-o"));
    auto const output_filepath{ relative_to_cache_dir(output_filename) };
    compiler_args.push_back(strdup(output_filepath.c_str()));

    /* Required because of `strdup` usage and need to manually free the memory.
     * Clang expects C strings that we own. */
    util::scope_exit const cleanup{ [&]() {
      for(auto const s : compiler_args)
      {
        /* NOLINTNEXTLINE(cppcoreguidelines-no-malloc) */
        free(reinterpret_cast<void *>(const_cast<char *>(s)));
      }
    } };

    // for(auto const st : compiler_args)
    // {
    //   util::println("compilation command: {} ", compiler_args);
    // }

    llvm::ArrayRef<char const *> const Argv(compiler_args);

    auto compilation(driver.BuildCompilation(Argv));

    if(!compilation || compilation->containsError())
    {
      return error::aot_compilation_failure();
    }

    /* Execute the compilation jobs (preprocess, compile, assemble)
     * This actually runs the commands determined by BuildCompilation. */
    int exit_code{ 1 };
    if(compilation && !compilation->containsError())
    {
      llvm::SmallVector<std::pair<int, clang::driver::Command const *>> failing_commands;
      exit_code = driver.ExecuteCompilation(*compilation, failing_commands);

      for(auto const &failing_command : failing_commands)
      {
        /* Check if command signaled an error */
        if(failing_command.first < 0)
        {
          util::println(stderr,
                        "Error executing command: {}",
                        failing_command.second->getExecutable());

          /* TODO: We can print more details about the failing command failing_command.second */
        }
      }
    }

    if(diags.hasErrorOccurred() || exit_code != 0)
    {
      return error::aot_compilation_failure();
    }

    util::println("Compilation successful. Find the executable at: '{}'", output_filepath);

    return ok();
  }
}
