#include <fstream>
#include <vector>
#include <cstdlib>

#include <jtl/result.hpp>

#include <llvm/ADT/IntrusiveRefCntPtr.h>
#include <llvm/Option/OptTable.h>
#include <llvm/Support/Program.h>
#include <llvm/Support/TargetSelect.h>
#include <llvm/Support/VirtualFileSystem.h>
#include <llvm/Support/raw_ostream.h>
#include <llvm/TargetParser/Host.h>

#include <clang/Basic/DiagnosticIDs.h>
#include <clang/Basic/DiagnosticOptions.h>
#include <clang/Driver/Compilation.h>
#include <clang/Driver/Driver.h>
#include <clang/Driver/ToolChain.h>
#include <clang/Frontend/TextDiagnosticPrinter.h>

#include <jank/aot/processor.hpp>
#include <jank/util/cli.hpp>
#include <jank/util/fmt.hpp>
#include <jank/runtime/context.hpp>
#include <jank/runtime/module/loader.hpp>
#include <jank/util/fmt/print.hpp>
#include <jank/util/scope_exit.hpp>
#include <jank/util/string_builder.hpp>

namespace jank::aot
{
  using namespace jank::runtime;

  processor::processor(util::cli::options const &opts)
    : include_dirs{ opts.include_dirs }
    , library_dirs{ opts.library_dirs }
    , define_macros{ opts.define_macros }
    , libs{ opts.libs }
    , output_filename(opts.output_filename)
  {
  }

  static jtl::immutable_string relative_to_cache_dir(jtl::immutable_string const &file_path)
  {
    return util::format("{}/{}", __rt_ctx->binary_cache_dir, file_path);
  }

  static jtl::immutable_string gen_entrypoint(jtl::immutable_string const &module)
  {
    util::string_builder sb;
    sb(R"(/* DO NOT MODIFY: Autogenerated by jank. */

using jank_object_ref = void*;
using jank_bool = char;

    )");

    sb(R"(
extern "C" int jank_init(int const argc,
                     char const **argv,
                     jank_bool init_default_ctx,
                     int (*fn)(int const, char const **));
extern "C" jank_object_ref jank_var_intern(jank_object_ref ns, jank_object_ref var);
extern "C" jank_object_ref jank_call0(jank_object_ref f);
    )");

    sb(R"(
extern "C" jank_object_ref jank_load_clojure_core_native();
extern "C" jank_object_ref jank_load_clojure_string_native();
extern "C" jank_object_ref jank_load_jank_compiler_native();
extern "C" jank_object_ref jank_load_clojure_core();
extern "C" jank_object_ref jank_var_intern_c(char const *, char const *);
extern "C" jank_object_ref jank_deref(jank_object_ref);
extern "C" jank_object_ref jank_call0(jank_object_ref);
)");

    for(auto const &m : __rt_ctx->loaded_modules_in_order)
    {
      util::format_to(sb,
                      R"(extern "C" jank_object_ref {}();)",
                      module::module_to_load_function(m));
      sb("\n");
    }

    sb(R"(

int main(int argc, const char** argv)
{
  auto const fn{ [](int const argc, char const **argv) {
    jank_load_clojure_core_native();
    jank_load_clojure_string_native();
    jank_load_jank_compiler_native();

    )");

    for(auto const &m : __rt_ctx->loaded_modules_in_order)
    {
      util::format_to(sb, "{}();\n", module::module_to_load_function(m));
    }

    util::format_to(sb, R"(auto const fn(jank_var_intern_c("{}", "-main"));)", module);
    sb("\n");
    sb(R"(jank_call0(jank_deref(fn));

    return 0;

  } };

  return jank_init(argc, argv, /* init_default_ctx= */ true, fn);
}
  )");

    auto const tmp_dir{ std::filesystem::temp_directory_path() };
    std::string main_file_path{ tmp_dir / "jank-main-XXXXXX" };

    auto const fd{ mkstemp(main_file_path.data()) };
    close(fd);

    std::ofstream out(main_file_path);
    out << sb.release();

    out.flush();
    out.close();

    return main_file_path;
  }

  jtl::result<void, compiler_err> processor::compile(jtl::immutable_string const &module) const
  {
    auto const entrypoint_path{ gen_entrypoint(module) };

    llvm::IntrusiveRefCntPtr<clang::DiagnosticOptions> diag_opts{ new clang::DiagnosticOptions() };
    auto *diag_client{
      new clang::TextDiagnosticPrinter{ llvm::errs(), &*diag_opts }
    };
    llvm::IntrusiveRefCntPtr<clang::DiagnosticIDs> diag_id{ new clang::DiagnosticIDs() };
    clang::DiagnosticsEngine diags{ diag_id, &*diag_opts, diag_client, /*ShouldOwnClient=*/true };

    llvm::IntrusiveRefCntPtr<llvm::vfs::FileSystem> vfs{ llvm::vfs::getRealFileSystem() };

    std::string const target_triple{ llvm::sys::getDefaultTargetTriple() };

    /* The Driver needs the path to the executable (used for finding related tools/resources)
     * For this example, we'll use argv[0] or a placeholder. This might need adjustment
     * depending on how/where your program is run relative to clang resources.
     * TODO: Ensure correct clang++ version. Will be OS dependent. */
    auto const clang_inferred_path{ llvm::sys::findProgramByName("clang++") };
    if(!clang_inferred_path)
    {
      return jtl::err(
        compiler_err{ 1, "clang++ executable not found. Ensure it exists on the path!" });
    }
    clang::driver::Driver driver(clang_inferred_path.get(),
                                 target_triple,
                                 diags,
                                 "jank_aot_compilation",
                                 vfs);
    driver.setCheckInputsExist(false);

    std::vector<char const *> Args = { strdup(clang_inferred_path.get().c_str()) };

    for(auto const &module : __rt_ctx->loaded_modules_in_order)
    {
      auto const &module_path{ module::module_to_path(module) };
      Args.push_back(strdup(util::format("{}.o", relative_to_cache_dir(module_path)).c_str()));
    }

    Args.push_back(strdup("-x"));
    Args.push_back(strdup("c++"));
    Args.push_back(strdup(entrypoint_path.c_str()));

    for(auto const &include_dir : include_dirs)
    {
      Args.push_back(strdup(util::format("-I{}", include_dir).c_str()));
    }

    for(auto const &library_dir : library_dirs)
    {
      Args.push_back(strdup(util::format("-L{}", library_dir).c_str()));
    }

    for(auto const &lib : { "-ljank",
                            /* Default libraries that jank depends on. */
                            "-lfolly",
                            "-lstdc++",
                            "-lm",
                            "-lzip",
                            "-lzippp_static",
                            "-lcrypto",
                            "-lclang-cpp",
                            "-lgc",
                            "-lgccpp",
                            "-lnanobench",
                            "-lftxui-component",
                            "-lLLVM",
                            "-lftxui-dom",
                            "-lftxui-screen",
                            "-lcpptrace",
                            "-ldwarf" })
    {
      Args.push_back(strdup(lib));
    }

    for(auto const &define : define_macros)
    {
      Args.push_back(strdup(util::format("-D{}", define).c_str()));
    }

    Args.push_back(strdup("-std=c++20"));

    Args.push_back(strdup("-o"));
    auto const output_filepath{ relative_to_cache_dir(output_filename) };
    Args.push_back(strdup(output_filepath.c_str()));

    /* Required because of `strdup` usage and need to manually free the memory.
     * Clang expects C strings that we own. */
    util::scope_exit const cleanup{ [&]() {
      for(auto const s : Args)
      {
        /* NOLINTNEXTLINE(cppcoreguidelines-no-malloc) */
        free(reinterpret_cast<void *>(const_cast<char *>(s)));
      }
    } };

    llvm::ArrayRef<char const *> Argv(Args);

    std::unique_ptr<clang::driver::Compilation> C(driver.BuildCompilation(Argv));

    if(!C || C->containsError())
    {
      return jtl::err(compiler_err{ 1, "Failed to build compilation steps." });
    }

    /* Execute the compilation jobs (preprocess, compile, assemble)
     * This actually runs the commands determined by BuildCompilation. */
    int Result = 0;
    if(C && !C->containsError())
    {
      llvm::SmallVector<std::pair<int, clang::driver::Command const *>> FailingCommands;
      Result = driver.ExecuteCompilation(*C, FailingCommands);

      for(auto const &P : FailingCommands)
      {
        /* Check if command signaled an error */
        if(P.first < 0)
        {
          llvm::errs() << "Error executing command: " << P.second->getExecutable() << "\n";

          /* TODO: We can print more details about the failing command P.second */
        }
      }
    }
    else
    {
      Result = 1;
    }

    if(diags.hasErrorOccurred())
    {
      return jtl::err(compiler_err{ 1, "Compilation failed with errors.\n" });
    }

    if(Result == 0)
    {
      llvm::outs() << util::format("Compilation successful. Find the executable at: `{}`",
                                   output_filepath)
                        .c_str();
    }
    else
    {
      return jtl::err(compiler_err{ Result, "Compilation command execution failed.\n" });
    }

    return jtl::ok();
  }
}
