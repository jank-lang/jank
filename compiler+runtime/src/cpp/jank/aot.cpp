#include <fstream>
#include <iostream>
#include <vector>

#include <llvm/Support/TargetSelect.h>
#include <llvm/Support/VirtualFileSystem.h>
#include <llvm/Support/raw_ostream.h>
#include <llvm/ADT/IntrusiveRefCntPtr.h>
#include <llvm/Option/OptTable.h>
#include <llvm/TargetParser/Host.h>

#include <clang/Basic/DiagnosticIDs.h>
#include <clang/Basic/DiagnosticOptions.h>
#include <clang/Driver/Compilation.h>
#include <clang/Driver/Driver.h>
#include <clang/Driver/ToolChain.h>
#include <clang/Frontend/TextDiagnosticPrinter.h>

#include <jank/aot.hpp>
#include <jank/util/cli.hpp>
#include <jank/util/fmt.hpp>
#include <jank/runtime/context.hpp>
#include <jank/runtime/module/loader.hpp>
#include <jank/util/string_builder.hpp>
#include <jank/util/fmt/print.hpp>
#include <jank/util/scope_exit.hpp>

namespace jank
{
  using namespace jank::runtime;

  aot_compiler::aot_compiler(util::cli::options const &opts)
    : include_dirs{ opts.include_dirs }
    , library_dirs{ opts.library_dirs }
    , define_macros{ opts.define_macros }
    , libs{ opts.libs }
    , output_filename(opts.output_filename)
  {
  }

  static jtl::immutable_string relative_to_cache_dir(jtl::immutable_string const &file_path)
  {
    return jank::util::format("{}/{}", __rt_ctx->binary_cache_dir, file_path);
  }

  static void gen_entrypoint(jtl::immutable_string const &module)
  {
    util::string_builder sb;
    sb(R"(/* DO NOT MODIFY: Autogenerated by Jank Compiler. */

using jank_object_ref = void*;

namespace jank
{
  int init(int const argc,
           char const **argv,
           bool init_default_ctx,
           void (*fn)(int const argc, char const **argv));
}

    )");

    sb(R"(
extern "C" jank_object_ref jank_var_intern(jank_object_ref ns, jank_object_ref var);
extern "C" jank_object_ref jank_call0(jank_object_ref f);
    )");

    sb(R"(
extern "C" jank_object_ref jank_load_clojure_core_native();
extern "C" jank_object_ref jank_load_clojure_string_native();
extern "C" jank_object_ref jank_load_jank_compiler_native();
extern "C" jank_object_ref jank_load_clojure_core();
extern "C" jank_object_ref jank_var_intern_c(char const *, char const *);
extern "C" jank_object_ref jank_deref(jank_object_ref);
extern "C" jank_object_ref jank_call0(jank_object_ref);
)");

    for(auto const &m : __rt_ctx->loaded_modules_in_order)
    {
      sb(R"(extern "C" jank_object_ref )");
      sb(module::module_to_load_function(m));
      sb(R"(();)");
      sb("\n");
    }

    sb(R"(

int main(int argc, const char** argv)
{ // main start

  using namespace jank;

  auto const fn{ [](int const argc, char const **argv) {
    jank_load_clojure_core_native();
    jank_load_clojure_string_native();
    jank_load_jank_compiler_native();

    )");

    for(auto const &m : __rt_ctx->loaded_modules_in_order)
    {
      sb(module::module_to_load_function(m));
      sb(R"(();
      )");
    }

    sb(R"(

    // project modules loaded

    // main function being called
    
    auto const fn(jank_var_intern_c(")");

    sb(module);
    sb(R"(", "-main"));
    jank_call0(jank_deref(fn));

  } };

  return jank::init(argc, argv, /* init_default_ctx= */ true, fn);
}
  )");

    auto const main_file(relative_to_cache_dir("/jank_main.cpp"));

    std::ofstream out(main_file);
    out << sb.release();

    out.flush();
    out.close();
  }

  void aot_compiler::compile(jtl::immutable_string const &module) const
  {
    gen_entrypoint(module);

    llvm::IntrusiveRefCntPtr<clang::DiagnosticOptions> DiagOpts = new clang::DiagnosticOptions();

    auto *DiagClient = new clang::TextDiagnosticPrinter(llvm::errs(), &*DiagOpts);

    llvm::IntrusiveRefCntPtr<clang::DiagnosticIDs> DiagID(new clang::DiagnosticIDs());

    llvm::IntrusiveRefCntPtr<llvm::vfs::FileSystem> VFS = llvm::vfs::getRealFileSystem();

    clang::DiagnosticsEngine Diags(DiagID, &*DiagOpts, DiagClient, /*ShouldOwnClient=*/true);


    std::string const TargetTripleStr = llvm::sys::getDefaultTargetTriple();
    llvm::errs() << "Using target triple: " << TargetTripleStr << "\n";

    /* The Driver needs the path to the executable (used for finding related tools/resources)
     * For this example, we'll use argv[0] or a placeholder. This might need adjustment
     * depending on how/where your program is run relative to clang resources.
     * TODO: infer clang++ path. Will be OS dependent and will require to infer correct version's path */
    auto const ClangExecutablePath{ "/usr/bin/clang++" };
    clang::driver::Driver TheDriver(ClangExecutablePath,
                                    TargetTripleStr,
                                    Diags,
                                    "jank_aot_compilation",
                                    VFS);
    TheDriver.setCheckInputsExist(false);

    std::vector<char const *> Args = { strdup(ClangExecutablePath) };

    for(auto const &module : __rt_ctx->loaded_modules_in_order)
    {
      auto const &module_path{ module::module_to_path(module) };
      util::string_builder sb;

      Args.push_back(strdup(relative_to_cache_dir(module_path).c_str()));
    }

    Args.push_back(strdup(relative_to_cache_dir("jank_main.cpp").c_str()));

    for(auto const &include_dir : include_dirs)
    {
      Args.push_back(strdup(util::format("-I{}", include_dir).c_str()));
    }

    for(auto const &library_dir : library_dirs)
    {
      Args.push_back(strdup(util::format("-L{}", library_dir).c_str()));
    }

    for(auto const &lib : { "-ljank",
                            // Default libs that Jank depends on
                            "-lfolly",
                            "-lstdc++",
                            "-lm",
                            "-lzip",
                            "-lzippp_static",
                            "-lcrypto",
                            "-lclang-cpp",
                            "-lgc",
                            "-lgccpp",
                            "-lnanobench",
                            "-lftxui-component",
                            "-lLLVM",
                            "-lftxui-dom",
                            "-lftxui-screen",
                            "-lcpptrace",
                            "-ldwarf" })
    {
      Args.push_back(strdup(lib));
    }

    for(auto const &define : define_macros)
    {
      Args.push_back(strdup(util::format("-D{}", define).c_str()));
    }

    Args.push_back(strdup("-o"));
    auto const output_filepath{ relative_to_cache_dir(output_filename) };
    Args.push_back(strdup(output_filepath.c_str()));

    /* Required because of `strdup` usage and need to manually free the memory.
     * Clang expects C strings that we own. */
    util::scope_exit const cleanup{ [&]() {
      for(auto const s : Args)
      {
        // NOLINTNEXTLINE(cppcoreguidelines-no-malloc): Needs to free these strings becuase we strdupped them
        free(reinterpret_cast<void *>(const_cast<char *>(s)));
      }
    } };

    llvm::ArrayRef<char const *> Argv(Args);


    std::unique_ptr<clang::driver::Compilation> C(TheDriver.BuildCompilation(Argv));

    if(!C || C->containsError())
    {
      llvm::errs() << "Failed to build compilation steps.\n";
      // Diagnostics engine already printed errors.
      return;
    }

    // Execute the compilation jobs (preprocess, compile, assemble)
    // This actually runs the commands determined by BuildCompilation.
    int Result = 0;
    if(C && !C->containsError())
    {
      llvm::SmallVector<std::pair<int, clang::driver::Command const *>, 4> FailingCommands;
      Result = TheDriver.ExecuteCompilation(*C, FailingCommands);

      // Handle failing commands if any
      for(auto const &P : FailingCommands)
      {
        if(P.first < 0)
        { // Check if command signaled an error
          llvm::errs() << "Error executing command: " << P.second->getExecutable() << "\n";
          // We can print more details about the failing command P.second
        }
      }
    }
    else
    {
      Result = 1;
    }


    if(Diags.hasErrorOccurred())
    {
      llvm::errs() << "Compilation failed with errors.\n";
      return; // Ensure non-zero exit code on error
    }

    if(Result == 0)
    {
      llvm::outs() << util::format("Compilation successful. Find the executable at: `{}`",
                                   output_filepath)
                        .c_str();
    }
    else
    {
      llvm::errs() << "Compilation command execution failed.\n";
      return; // Return the driver's result code
    }
  }
}
